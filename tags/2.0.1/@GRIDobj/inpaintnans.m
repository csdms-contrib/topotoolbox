function DEM = inpaintnans(DEM,varargin)

% interpolate missing values in a grid (GRIDobj)
%
% Syntax
%
%     DEMf = inpaintnans(DEM,type,k)
%
% Description
% 
%     inpaintnans fills gaps in a grid (GRIDobj) generated by measurement
%     errors or missing values. The user may choose between different
%     techniques to fill the gaps. Note that the algorithm fills only
%     pixels not connected to the DEM grid boundaries.
%
% Input
%
%     DEM      digital elevation model with missing values
%               indicated by nans (GRIDobj)
%     type      fill algorithm 
%               'laplace' (default): laplace interpolation 
%                     as implemented in roifill
%               'fill': elevate all values in each connected
%                     region of missing values to the minimum
%                     value of the surrounding pixels (same as 
%                     the function nibble in ArcGIS Spatial Analyst)
%               'nearest': nearest neighbor interpolation 
%                     using bwdist
%     k         if supplied, only connected components with 
%               less or equal number of k pixels are filled. Others
%               remain nan
%
% Output
%
%     DEM      processed digital elevation model (GRIDobj)
%
% Example
%     
%     load exampleDEM
%     I = full(sprand(size(dem,1),size(dem,2),0.05) > 0);
%     dem(I) = nan;
%     demf = deminpaint(dem);
% 
% See also: ROIFILL, FILLSINKS, BWDIST
%
% Author: Wolfgang Schwanghart (w.schwanghart[at]geo.uni-potsdam.de)
% Date: 26. January, 2012

DEM.Z = deminpaint(DEM.Z,varargin{:});

end

function dem = deminpaint(dem,type,k)
if nargin == 1;
    type = 'laplace';
    k    = inf;
elseif nargin == 2;
    k    = inf;
end
   
% error checking    
% clean boundary
I = isnan(dem);
I = imclearborder(I);

if ~isinf(k)
    I = xor(bwareaopen(I,k+1),I);
end

% 
if numel(dem) < 10000^2 || ~strcmpi(type,'laplace');

% interpolation
switch lower(type)
    case 'nearest'
        % nearest neighbor interpolation
        [~,L] = bwdist(~I);
        dem = dem(L);
    case 'laplace'
        % use roifill
        dem = roifill(dem,imdilate(I,ones(3)));
    case 'fill'
        % fill to lowest surrounding neighbor
        marker = inf(size(dem),class(dem));
        markerpixels = imdilate(I,ones(3)) & ~I;
        marker(markerpixels) = dem(markerpixels);
        mask = dem;
        mask(I | isnan(dem)) = -inf;
        marker = -marker;
        mask   = -mask;
        demrec = imreconstruct(marker,mask);
        dem(I) = -demrec(I);
    otherwise
        error('type unknown')
end

else
    CC = bwconncomp(I);
    STATS = regionprops(CC,'SubarrayIdx','Image');
    
    for r = 1:numel(STATS);
        rows = STATS(r).SubarrayIdx{1};
        rows = [min(rows)-1 max(rows)+1];
        cols = STATS(r).SubarrayIdx{2};
        cols = [min(cols)-1 max(cols)+1];
        
        demtemp = dem(rows(1):rows(2),cols(1):cols(2));
        inatemp = padarray(STATS(r).Image,[1 1],false);
        demtemp = roifill(demtemp,imdilate(inatemp,ones(3)));    
        dem(rows(1):rows(2),cols(1):cols(2)) = demtemp;
    end
end
end
